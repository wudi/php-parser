# RustPHP Virtual Machine Design Specification

## 1. Executive Summary
This document outlines the architecture for a high-performance PHP Virtual Machine (VM) written in Rust.

**Key Design Decisions:**
*   **Architecture:** Stack-based Bytecode Interpreter.
*   **Memory Management:** **Arena-based (Region Allocation)**. No Garbage Collector (GC) or Reference Counting (`Rc`). All values live in a contiguous `Vec`, addressed by integer `Handles`. Memory is freed in bulk at the end of the request.
*   **Concurrency:** Shared-Nothing Architecture. Immutable built-ins are shared across threads; request data is isolated.
*   **Compilation:** Just-in-Time compilation from AST to Bytecode Chunks.

---

## 2. Directory Structure & Module Breakdown

```text
src/
├── core/
│   ├── mod.rs
│   ├── value.rs        # The Zval enum and Handle types
│   ├── heap.rs         # The Arena (Memory Manager)
│   ├── array.rs        # PHP Array implementation (IndexMap wrapper)
│   └── interner.rs     # Symbol Interning (Strings -> u32)
├── compiler/
│   ├── mod.rs
│   ├── emitter.rs      # AST -> OpCode translation
│   └── chunk.rs        # Bytecode container (CodeChunk)
├── vm/
│   ├── mod.rs
│   ├── engine.rs       # Main VM Loop
│   ├── stack.rs        # Operand Stack & Call Stack
│   ├── opcode.rs       # Instruction definitions
│   └── frame.rs        # Execution Context
├── builtins/
│   ├── mod.rs
│   ├── stdlib.rs       # Standard PHP functions (strlen, etc.)
│   └── classes.rs      # Built-in classes (stdClass, Exception)
└── runtime/
    ├── mod.rs
    ├── context.rs      # Request vs Engine contexts
    └── registry.rs     # Script/File cache
```

---

## 3. Core Data Structures (`src/core/`)

### 3.1 Handles & Values
Instead of pointers, we use `Handle` (an index into the Arena). This solves Rust lifetime issues and creates a "No-GC" system.

```rust
// core/value.rs
use indexmap::IndexMap;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Handle(pub u32);

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Symbol(pub u32); // Interned String

#[derive(Debug, Clone)]
pub enum Val {
    Null,
    Bool(bool),
    Int(i64),
    Float(f64),
    String(Vec<u8>), // PHP strings are byte arrays
    Array(IndexMap<ArrayKey, Handle>), // Recursive handles
    Object(ObjectData),
    Resource(Box<dyn std::any::Any>),
}

#[derive(Debug, Clone, Hash, Eq, PartialEq)]
pub enum ArrayKey {
    Int(i64),
    Str(Vec<u8>)
}

// The Container (Zval equivalent)
pub struct Zval {
    pub value: Val,
    pub is_ref: bool, // Explicit Reference Flag (&$a)
}
```

### 3.2 The Arena (Heap)
The single source of truth for all data in a request.

```rust
// core/heap.rs
pub struct Arena {
    storage: Vec<Zval>,
    free_slots: Vec<usize>, // For reuse during request
}

impl Arena {
    pub fn alloc(&mut self, val: Val) -> Handle { ... }
    pub fn get(&self, h: Handle) -> &Zval { ... }
    pub fn get_mut(&mut self, h: Handle) -> &mut Zval { ... }
}
```

---

## 4. The Compiler (`src/compiler/`)

Converts the AST generated by your parser into flat bytecode chunks.

### 4.1 Bytecode Structure

```rust
// compiler/chunk.rs
pub struct CodeChunk {
    pub name: Symbol,         // File/Func name
    pub code: Vec<OpCode>,    // Instructions
    pub constants: Vec<Val>,  // Literals (Ints, Strings)
    pub lines: Vec<u32>,      // Line numbers for debug
}
```

### 4.2 OpCodes
Designed for a stack machine.

```rust
// vm/opcode.rs
pub enum OpCode {
    // Stack Ops
    Const(u16),      // Push constant from table
    Pop,
    
    // Arithmetic
    Add, Sub, Mul, Div, Concat,

    // Variables
    LoadVar(Symbol),  // Push local variable value
    StoreVar(Symbol), // Pop value, store in local
    
    // Control Flow
    Jmp(u32),
    JmpIfFalse(u32),
    
    // Functions
    Call(u8),        // Call function with N args
    Return,
    
    // System
    Include,         // Runtime compilation
    Echo,
}
```

---

## 5. The Virtual Machine (`src/vm/`)

### 5.1 VM State
The VM holds the mutable state of the execution.

```rust
// vm/engine.rs
pub struct VM {
    pub arena: Arena,               // The Heap
    pub operand_stack: Vec<Handle>, // The Math Stack
    pub frames: Vec<CallFrame>,     // The Call Stack
    pub context: RequestContext,    // Globals, Constants
    pub ip: usize,                  // Current Instruction Pointer
}
```

### 5.2 Call Frame
Represents the scope of a function execution or file inclusion.

```rust
// vm/frame.rs
pub struct CallFrame {
    pub chunk: Rc<CodeChunk>,
    pub ip: usize,             // Return Address
    pub fp: usize,             // Frame Pointer (Stack offset)
    pub locals: HashMap<Symbol, Handle>, // Local Symbol Table
}
```

### 5.3 Execution Loop
The main heartbeat of the application.

```rust
impl VM {
    pub fn run(&mut self) -> Result<(), VmError> {
        loop {
            let frame = self.current_frame_mut();
            if frame.ip >= frame.chunk.code.len() {
                // End of chunk
                break;
            }
            
            let op = frame.chunk.code[frame.ip];
            frame.ip += 1;
            
            match op {
                OpCode::Add => self.op_add(),
                OpCode::LoadVar(sym) => self.op_load(sym),
                OpCode::Call(n) => self.op_call(n)?,
                OpCode::Include => self.op_include()?,
                // ...
            }
        }
    }
}
```

---

## 6. Built-in System (`src/runtime/` & `src/builtins/`)

Distinguishes between immutable engine data and mutable request data.

### 6.1 Function Signatures
Unified signature for User and Native functions.

```rust
// runtime/context.rs

// Native functions need access to VM to dereference Handles
pub type NativeHandler = fn(&mut VM, args: &[Handle]) -> Result<Handle, String>;

pub enum Callable {
    User(Rc<UserFunc>),
    Native(NativeHandler),
}
```

### 6.2 Immutable Engine Context (Shared)
Loaded once at startup (Arc).

```rust
pub struct EngineContext {
    pub functions: HashMap<Symbol, NativeHandler>, // strlen, etc.
    pub classes: HashMap<Symbol, ClassDef>,        // stdClass
    pub constants: HashMap<Symbol, Val>,           // PHP_VERSION
}
```

### 6.3 Mutable Request Context (Unique)
Created per request.

```rust
pub struct RequestContext {
    pub engine: Arc<EngineContext>,     // Link to shared
    pub globals: HashMap<Symbol, Handle>, // $_GET, $_POST
    pub user_functions: HashMap<Symbol, Rc<CodeChunk>>,
    pub included_files: HashSet<String>,
}
```

---

## 7. Key Algorithms & Implementation Details

### 7.1 Pass-By-Reference & Copy-on-Write (COW)
Since we use Handles, "Reference" means two variables hold the same Handle index.

**Writing Logic (`StoreVar`):**
1.  Look up variable in `locals`. Get `Handle(A)`.
2.  `vm.arena.get(Handle(A))`.
3.  **If `zval.is_ref == true`:**
    *   Mutate the value *inside* `Handle(A)` directly.
4.  **If `zval.is_ref == false`:**
    *   **Clone:** `vm.arena.alloc(zval.value.clone())` -> Get `Handle(B)`.
    *   Update `locals` to point to `Handle(B)`.
    *   (This preserves COW semantics).

### 7.2 The `include` Mechanism
Runtime compilation handling.

1.  **OpCode:** `Include` pops filename string from stack.
2.  **Resolve:** Check `ScriptRepository` cache. If miss, read file -> Parse -> Compile -> Store `CodeChunk` in `ScriptRepository`.
3.  **Context:**
    *   Create new `CallFrame`.
    *   **Crucial:** Copy the `locals` Handles from the *current* frame to the *new* frame (variable inheritance).
    *   Push Frame to VM.
4.  **Resume:** VM loop continues, now executing instructions from the new Chunk.

### 7.3 Native Function Interop
How Rust functions interact with the Arena.

```rust
// builtins/stdlib.rs

fn php_strlen(vm: &mut VM, args: &[Handle]) -> Result<Handle, String> {
    if args.is_empty() { return Err("Expects 1 arg".into()); }
    
    // 1. Dereference Handle to get Value
    let zval = vm.arena.get(args[0]);
    
    // 2. Logic
    let len = match &zval.value {
        Val::String(s) => s.len() as i64,
        _ => return Err("TypeError".into())
    };
    
    // 3. Allocate Result
    let res_handle = vm.arena.alloc(Val::Int(len));
    Ok(res_handle)
}
```

---

## 8. Implementation Roadmap

### Phase 1: The Calculator (Foundations)
1.  Implement `Arena` and `Handle`.
2.  Implement `Val::Int` and `Val::Float`.
3.  Implement Stack `push`/`pop`.
4.  Implement `OpCode::Add`, `Sub`, `Mul`.
5.  **Test:** Execute `1 + 2 * 3`.

### Phase 2: The Interpreter (Control Flow)
1.  Implement `CallFrame` and Loop.
2.  Implement `OpCode::Jmp` and `JmpIfFalse`.
3.  Implement `SymbolTable` (Locals).
4.  **Test:** `if ($a) { ... } else { ... }`.

### Phase 3: The Library (Strings & IO)
1.  Add `Val::String` (Vec<u8>).
2.  Implement `OpCode::Echo`.
3.  Implement `EngineContext` and `NativeHandler`.
4.  Add `strlen` and `str_repeat`.
5.  **Test:** `echo str_repeat("hi", 3);`.

### Phase 4: The Composer (Files & Functions)
1.  Implement `OpCode::Call` (Stack frame management).
2.  Implement `OpCode::Include` (Runtime parser invocation).
3.  Implement `OpCode::Return`.
4.  **Test:** Recursion and multi-file scripts.

### Phase 5: The Complex Types (Arrays & refs)
1.  Implement `Val::Array` using `indexmap`.
2.  Implement `Val::Reference` logic (The COW check).
3.  Implement Array operators (`[]`, `=>`).

---

## 9. Future Considerations
*   **Memory Safety:** Implement a hard limit on `Arena` size (e.g., 128MB) to simulate PHP's `memory_limit` and prevent OOM kills.
*   **Performance:** Implement "Computed GOTO" or "Threaded Code" dispatch for the VM loop to reduce CPU branch prediction misses.
*   **Reflection:** Add `OpCode::New` and `ClassDef` logic for OOP support.