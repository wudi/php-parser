# GEMINI.md: Project Overview and Development Guide

This document provides a comprehensive overview of the `php-parser-rs` project, its architecture, and development conventions to serve as a guide for AI-assisted development.

## 1. Project Overview

This project is a high-performance, fault-tolerant **PHP parser and an accompanying Virtual Machine (VM)**, written entirely in Rust. It aims to provide a robust foundation for PHP tooling (e.g., linters, IDEs, static analysis) and a standalone interpreter capable of executing PHP code.

The workspace is divided into two primary crates:

*   `crates/php-parser`: A zero-copy, resilient parser that converts PHP source code (as bytes) into an Abstract Syntax Tree (AST).
*   `crates/php-vm`: A virtual machine that compiles the AST from `php-parser` into bytecode and executes it. It includes implementations for various standard PHP extensions like PDO, MySQLi, OpenSSL, and Zlib.

### Key Architectural Principles

The project is built on several core principles to ensure performance and robustness:

*   **Zero-Copy & Arena Allocation**: The parser uses `bumpalo` for arena allocation. All AST nodes are allocated within this arena, avoiding heap allocations (`Box`, `Vec`, `String`) entirely. This results in excellent cache locality and performance.
*   **Resilience & Fault Tolerance**: The parser is designed to **never panic**. When it encounters a syntax error, it creates an `Error` node in the AST and synchronizes to the next valid statement or expression. This makes it suitable for tools that need to analyze incomplete or incorrect code.
*   **Byte-Oriented Processing**: The parser operates on byte slices (`&[u8]`) rather than strings (`&str`). This allows it to handle files with mixed or invalid UTF-8 encodings gracefully, a common scenario in legacy PHP projects.
*   **Hybrid Parsing Strategy**: The parser employs a combination of Recursive Descent for statements and Pratt Parsing for expressions, which is highly effective for languages with complex operator precedence rules like PHP.

## 2. Building and Running

The following commands are standard for this project. They are derived from the CI workflow (`.github/workflows/ci.yml`).

#### Build the Workspace
To build both the parser and the VM:
```bash
cargo build
```

#### Run the Test Suite
To run all unit and integration tests:
```bash
cargo test
```
**Note**: This project uses `insta` for snapshot testing. If you make a change that alters the AST, you may need to review and accept the changes:
```bash
cargo insta review
```

#### Check Code Formatting
The project enforces a consistent code style using `rustfmt`. To check for formatting issues:
```bash
cargo fmt --all -- --check
```

#### Lint the Code
The project uses `clippy` with a strict warning policy. To check for lints:
```bash
cargo clippy --all-targets --all-features -- -D warnings
```

#### Run the PHP Interpreter
The `php-vm` crate builds an executable binary named `php`. You can use it to run PHP scripts:
```bash
cargo run --bin php -- examples/hash_demo.php
```

## 3. Development Conventions

Adherence to these conventions is crucial for maintaining code quality and consistency.

#### Code Style and Linting
*   All code **must** be formatted with `rustfmt` before being committed.
*   Code must be free of `clippy` warnings. The CI enforces a "deny warnings" policy.

#### Memory Management
*   The AST produced by the parser **must not** contain any direct heap allocations.
*   Use arena-allocated references (`&'ast T`) and slices (`&'ast [T]`) for all nodes within the AST. This is a fundamental architectural constraint.

#### Error Handling
*   The **parser must never panic**. All parsing errors should be captured as `Error` nodes within the AST.
*   Implement recovery logic (synchronization) in the parser to ensure it can continue parsing after an error.

#### Testing
The project relies on a multi-layered testing strategy:
1.  **Unit Tests**: For discrete functions and logic, especially in the lexer.
2.  **Snapshot Tests (`insta`)**: To detect any regressions in the structure of the AST generated by the parser. These are the most common type of test you will encounter.
3.  **Recovery Tests**: To verify that the parser correctly handles syntax errors and recovers as expected.
4.  **Corpus Tests**: To ensure the parser is stable when processing large, real-world PHP codebases like WordPress or Laravel.
